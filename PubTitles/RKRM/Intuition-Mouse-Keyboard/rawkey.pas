program rawkey;

{$IFNDEF HASAMIGA}
{$FATAL This source is compatible with Amiga, AROS and MorphOS only !}
{$ENDIF}

{
  Project   : rawkey
  Topic     : How to correctly convert from RAWKEY to keymapped ASCII
  Source    : RKRM
}

{*
** The following example uses RawKeyConvert() to convert the
** IDCMP_RAWKEY input stream into an ANSI input stream.  See the
** "Console Device" chapter in the Amiga ROM Kernel Reference Manual:
** Devices for more information on RawKeyConvert() and the data it
** returns.
*}


{$MODE OBJFPC}{$H+}{$HINTS ON}

{$UNITPATH ../../../Base/CHelpers}
{$UNITPATH ../../../Base/Trinity}

{$IFDEF AMIGA}   {$UNITPATH ../../../Sys/Amiga}   {$ENDIF}
{$IFDEF AROS}    {$UNITPATH ../../../Sys/AROS}    {$ENDIF}
{$IFDEF MORPHOS} {$UNITPATH ../../../Sys/MorphOS} {$ENDIF}


Uses
  Exec, InputEvent, KeyMap, Intuition, Utility, Console,
  {$IFDEF AMIGA}
  systemvartags,
  {$ENDIF}
  Trinity,
  CHelpers,
  SysUtils;


  //* our function prototypes */
  function  deadKeyConvert(msg: PIntuiMessage; kbuffer: PChar; kbsize: LONG; kmap: PKeyMap; ievent: PInputEvent): LONG; forward;
  procedure print_qualifiers(qual: ULONG); forward;
  function  doKeys(msg: PIntuiMessage; ievent: PInputEvent; buffer: PPChar; bufsize: PULONG): WordBool; forward;
  procedure process_window(win: PWindow; ievent: PInputEvent; buffer: PPChar; bufsize: PULONG); forward;
  

const
  {* A buffer is created for RawKeyConvert() to put its output. BUFSIZE is the size of
  ** the buffer in bytes.  NOTE that this program starts out with a buffer size of 2.
  ** This is only to show how the buffer is automatically increased in size  by this
  ** example!  In an application, start with a much larger buffer and you will probably
  ** never have to increase its size. 128 bytes or so should do the trick, but always
  ** be able to change the size if required.
  *}
  BUFFERSIZE = (2);

var
  {$IFDEF MORPHOS}
  IntuitionBase : PLibrary absolute Intuition.Intuitionbase;
  {$ENDIF}
  ConsoleDevice : PLibrary absolute Console.ConsoleDevice;

//* main() - set-up everything used by program. */
procedure Main(argc: Integer; argv: PPChar);
var
  win       : PWindow;
  ioreq     : TIOStdReq;
  ievent    : PInputEvent;
  buffer    : PChar;
  bufsize   : ULONG = BUFFERSIZE;
begin
  {$IFDEF MORPHOS}
  If SetAndtest(IntuitionBase, OpenLibrary('intuition.library', 37)) then
  {$ENDIF}
  begin
    //* Open the console device just to do keymapping. (unit -1 means any unit) */
    if (0 = OpenDevice('console.device', ULONG(-1), PIORequest(@ioreq), 0)) then
    begin
      ConsoleDevice := PLibrary(ioreq.io_Device);

      {* Allocate the initial character buffer used by deadKeyConvert() and RawKeyConvert()
      ** for returning translated characters. If the characters generated by these routines
      ** cannot fit into the buffer, the application must pass a larger buffer.  This is
      ** done in this code by freeing the old buffer and allocating a new one.
      *}
      if SetAndTest(buffer, ExecAllocMem(bufsize, MEMF_CLEAR)) then
      begin
        if SetAndTest(ievent, ExecAllocMem(sizeof(TInputEvent), MEMF_CLEAR)) then
        begin
          if SetAndTest(win, OpenWindowTags(nil,
          [
            TAG_(WA_Width)    , 300,
            TAG_(WA_Height)   , 50,
            TAG_(WA_Flags)    , WFLG_DEPTHGADGET or WFLG_CLOSEGADGET or WFLG_ACTIVATE,
            TAG_(WA_IDCMP)    , IDCMP_CLOSEWINDOW or IDCMP_RAWKEY,
            TAG_(WA_Title)    , TAG_(PChar('Raw Key Example')),
            TAG_END
          ])) then
          begin
            WriteLn('Press keyboard keys to see ASCII conversion from rawkey');
            WriteLn(Format('Unprintable characters will be shown as %s', [#$7F]));
            WriteLn;
            process_window(win, ievent, @buffer, @&bufsize);
            CloseWindow(win);
          end;
          ExecFreeMem(ievent, sizeof(TInputEvent));
        end;
        //* Buffer can be freed elsewhere in the program so test first. */
        if (buffer <> nil)
          then ExecFreeMem(buffer, bufsize);
      end;
      CloseDevice(PIORequest(@ioreq));
    end;
    {$IFDEF MORPHOS}
    CloseLibrary(IntuitionBase);
    {$ENDIF}
  end;
end;


{* Convert RAWKEYs into VANILLAKEYs, also shows special keys like HELP, Cursor Keys,
** FKeys, etc.  It returns:
**   -2 if not a RAWKEY event.
**   -1 if not enough room in the buffer, try again with a bigger buffer.
**   otherwise, returns the number of characters placed in the buffer.
*}
function  deadKeyConvert(msg: PIntuiMessage; kbuffer: PChar; kbsize: LONG; kmap: PKeyMap; ievent: PInputEvent): LONG;
begin
  if (msg^.IClass <> IDCMP_RAWKEY) then exit(-2);
  ievent^.ie_Class := IECLASS_RAWKEY;
  ievent^.ie_Code := msg^.Code;
  ievent^.ie_Qualifier := msg^.Qualifier;
  ievent^.ie_position.ie_addr := (PAPTR(msg^.IAddress))^;

  result := (RawKeyConvert(ievent, kbuffer, kbsize, kmap));
end;


{* print_qualifiers() - print out the values found in the qualifier bits of
** the message. This will print out all of the qualifier bits set.
*}
procedure print_qualifiers(qual: ULONG);
begin
  Write('Qual:');
  if (qual and IEQUALIFIER_LSHIFT <> 0)          then Write('LShft,');
  if (qual and IEQUALIFIER_RSHIFT <> 0)          then Write('RShft,');
  if (qual and IEQUALIFIER_CAPSLOCK <> 0)        then Write('CapLok,');
  if (qual and IEQUALIFIER_CONTROL <> 0)         then Write('Ctrl,');
  if (qual and IEQUALIFIER_LALT <> 0)            then Write('LAlt,');
  if (qual and IEQUALIFIER_RALT <> 0)            then Write('RAlt,');
  if (qual and IEQUALIFIER_LCOMMAND <> 0)        then Write('LCmd,');
  if (qual and IEQUALIFIER_RCOMMAND <> 0)        then Write('RCmd,');
  if (qual and IEQUALIFIER_NUMERICPAD <> 0)      then Write('NumPad,');
  if (qual and IEQUALIFIER_REPEAT <> 0)          then Write('Rpt,');
  if (qual and IEQUALIFIER_INTERRUPT <> 0)       then Write('Intrpt,');
  if (qual and IEQUALIFIER_MULTIBROADCAST <> 0)  then Write('Multi Broadcast,');
  if (qual and IEQUALIFIER_MIDBUTTON <> 0)       then Write('MidBtn,');
  if (qual and IEQUALIFIER_RBUTTON <> 0)         then Write('RBtn,');
  if (qual and IEQUALIFIER_LEFTBUTTON <> 0)      then Write('LBtn,');
  if (qual and IEQUALIFIER_RELATIVEMOUSE <> 0)   then Write('RelMouse,');
end;


//* doKeys() - Show what keys were pressed. */
function  doKeys(msg: PIntuiMessage; ievent: PInputEvent; buffer: PPChar; bufsize: PULONG): WordBool;
var
  char_pos  : Integer;
  numchars  : integer;
  ret_code  : WordBool = TRUE;
  realc, c  : Byte;
begin
  {* deadKeyConvert() returns -1 if there was not enough space in the buffer to
  ** convert the string. Here, the routine increases the size of the buffer on the
  ** fly...Set the return code to FALSE on failure.
  *}
  numchars := deadKeyConvert(msg, buffer^, bufsize^ - 1, nil, ievent);
  while ((numchars = -1) and (buffer^ <> nil)) do
  begin
    //* conversion failed, buffer too small. try to double the size of the buffer. */
    ExecFreeMem(buffer^, bufsize^);
    bufsize^ := bufsize^ shl 1;
    writeLn(Format('Increasing buffer size to %d', [bufsize^]));

    if (nil = SetAndGet(buffer^, ExecAllocMem(bufsize^, MEMF_CLEAR)))
    then ret_code := FALSE
    else  numchars := deadKeyConvert(msg, buffer^, bufsize^ - 1, nil, ievent);
  end;

  //* numchars contains the number of characters placed within the buffer.  Key up events and   */
  //* key sequences that do not generate any data for the program (like deadkeys) will return   */
  //* zero.  Special keys (like HELP, the cursor keys, FKeys, etc.) return multiple characters  */
  //* that have to then be parsed by the application.  Allocation failed above if buffer is NULL*/
  if (buffer^ <> nil) then
  begin
    //* if high bit set, then this is a key up otherwise this is a key down */
    if (msg^.Code and $80 <> 0)
    then Write('Key Up:   ')
    else Write('Key Down: ');

    print_qualifiers(msg^.Qualifier);
    WriteLn(Format(' rawkey #%d maps to %d ASCII character(s)', [$7F and msg^.Code, numchars]));
    for char_pos := 0 to Pred(numchars) do
    begin
      c := Byte(buffer^[char_pos]);
      realc := c;
      if ((c <= $1F) or ((c >= $80) and (c < $a0)))
      then c := $7f;
      WriteLn(Format('  %3d ($%.02x) = %s', [realc, realc, Char(c)]));
    end;
  end;
  Result := (ret_code);
end;


{* process_window() - simple event loop.  Note that the message is not replied
** to until the end of the loop so that it may be used in the doKeys() call.
*}
procedure process_window(win: PWindow; ievent: PInputEvent; buffer: PPChar; bufsize: PULONG);
var
  msg  : PIntuiMessage;
  done : WordBool;
begin
  done := FALSE;
  while (done = FALSE) do
  begin
    Wait((1 shl win^.UserPort^.mp_SigBit));
    while ((done = FALSE) and SetAndTest(msg, PIntuiMessage(GetMsg(win^.UserPort)))) do
    begin
      case (msg^.IClass) of   //* handle our events */
        IDCMP_CLOSEWINDOW:
        begin
          done := TRUE;
        end;
        IDCMP_RAWKEY:
        begin
          if (FALSE = doKeys(msg, ievent, buffer, bufsize))
          then done := TRUE;
        end;
      end;
      ReplyMsg(PMessage(msg));
    end;
  end;
end;


begin
  Main(ArgC, ArgV);
end.
